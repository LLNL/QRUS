
#ifndef USE_IOSTREAM
#  define USE_IOSTREAM 1
#endif
#ifndef USE_CMATH
#  define USE_CMATH 1
#endif
#ifndef USE_ASM
#  define USE_ASM_ALTERNATIVES 0
#endif

#if USE_IOSTREAM
#  include <iostream>
#endif

#if USE_CMATH
#include <cmath>
#elif USE_ASM_ALTERNATIVES
double inline __declspec (naked) __fastcall sqrt(double n) {
	_asm fld qword ptr [esp+4]
	_asm fsqrt
	_asm ret 8
}
#else
double sqrt(const double fg) {
 double n = fg / 2.0;
 double lstX = 0.0; 
 while (n != lstX) { 
    lstX = n;
    n = (n + fg/n) / 2.0; 
  }
  return n;
}
#endif

typedef double   Real;
typedef unsigned Index;

template <typename ProblemT>
struct System {
  Real time;                                                       ///< Current time

  Real px [ProblemT::counts::mobiles + ProblemT::counts::anchors]; ///< Position along the X axis of the mobile nodes followed by the anchor nodes
  Real py [ProblemT::counts::mobiles + ProblemT::counts::anchors]; ///< Position along the Y axis of the mobile nodes followed by the anchor nodes
  Real pz [ProblemT::counts::mobiles + ProblemT::counts::anchors]; ///< Position along the Z axis of the mobile nodes followed by the anchor nodes

  Real vx [ProblemT::counts::mobiles];                             ///< Velocity along the X axis of the mobile nodes
  Real vy [ProblemT::counts::mobiles];                             ///< Velocity along the Y axis of the mobile nodes
  Real vz [ProblemT::counts::mobiles];                             ///< Velocity along the Z axis of the mobile nodes

  Real fx [ProblemT::counts::mobiles + ProblemT::counts::anchors]; ///< Force exerted along the X axis on the mobile nodes then anchor nodes
  Real fy [ProblemT::counts::mobiles + ProblemT::counts::anchors]; ///< Force exerted along the Y axis on the mobile nodes then anchor nodes
  Real fz [ProblemT::counts::mobiles + ProblemT::counts::anchors]; ///< Force exerted along the Z axis on the mobile nodes then anchor nodes

  Real mass   [ProblemT::counts::mobiles];                         ///< Mass of the mobile nodes
  Real charge [ProblemT::counts::mobiles];                         ///< Charge of the mobile nodes

  Index springs  [ProblemT::counts::springs * 2];                  ///< Springs between pairs of nodes
  Real  tension  [ProblemT::counts::springs];                      ///< Tension coeficiant of the springs
  Real  friction [ProblemT::counts::springs];                      ///< Friction coeficiant of the springs
  Real  length   [ProblemT::counts::springs];                      ///< Nominal length of the springs


  System() : time(0.) {
    ProblemT::initializers::anchors(px + ProblemT::counts::mobiles, py + ProblemT::counts::mobiles, pz + ProblemT::counts::mobiles);
    ProblemT::initializers::mobiles(px, py, pz, vx, vy, vz, mass, charge);
    ProblemT::initializers::springs(springs, tension, friction, length);
    compute_forces();
  }

  void compute_forces() {

    for (Index i = 0; i < ProblemT::counts::mobiles + ProblemT::counts::anchors; ++i) {
      Real const x = px[i];
      Real const y = py[i];
      Real const z = pz[i];

      // Compute effect of global force field (such as gravity)
      fx[i] = ProblemT::fields::force::x(time, x, y, z);
      fy[i] = ProblemT::fields::force::y(time, x, y, z);
      fz[i] = ProblemT::fields::force::z(time, x, y, z);

      // Electric and magnetic fields apply to mobile nodes only (anchor have no charge)
      if (i < ProblemT::counts::mobiles) {
        Real const C = charge[i];
        if (C != 0.) {
          Real const mx = ProblemT::fields::magnetic::x(time, x, y, z);
          Real const my = ProblemT::fields::magnetic::y(time, x, y, z);
          Real const mz = ProblemT::fields::magnetic::z(time, x, y, z);

          fx[i] += C * (my * vz[i] - mz * vy[i] + ProblemT::fields::electric::x(time, x, y, z));
          fy[i] += C * (mz * vx[i] - mx * vz[i] + ProblemT::fields::electric::y(time, x, y, z));
          fz[i] += C * (mx * vy[i] - my * vx[i] + ProblemT::fields::electric::z(time, x, y, z));
        }
      }
    }

    // Compute the forces generated by the springs

    for (Index i = 0; i < ProblemT::counts::springs; ++i) {
      Index const n0 = springs[2*i];
      Index const n1 = springs[2*i+1];

      // dp: delta-position
      Real const dpx = px[n0] - px[n1];
      Real const dpy = py[n0] - py[n1];
      Real const dpz = pz[n0] - pz[n1];

      // dv: delta-velocity
      Real const dvx = vx[n0] - vx[n1];
      Real const dvy = vy[n0] - vy[n1];
      Real const dvz = vz[n0] - vz[n1];

      Real const norm = sqrt(dpx*dpx+dpy*dpy+dpz*dpz);
      Real const dp_coef = tension[i]  * ( 1. - length[i] / norm );

      Real const dpdv_prod = dpx*dvx + dpy*dvy + dpz*dvz;
      Real const dpdv_prod_sqrt = dpdv_prod > 0 ? sqrt(dpdv_prod) : sqrt(-dpdv_prod);
      Real const dv_coef = friction[i] * dpdv_prod_sqrt / norm;

      fx[n0] -= (dp_coef + dv_coef) * dpx; fx[n1] += (dp_coef + dv_coef) * dpx;
      fy[n0] -= (dp_coef + dv_coef) * dpy; fy[n1] += (dp_coef + dv_coef) * dpy;
      fz[n0] -= (dp_coef + dv_coef) * dpz; fz[n1] += (dp_coef + dv_coef) * dpz;
    }
  }

  void apply_forces(Real const & dt) {
    for (Index i = 0; i < ProblemT::counts::mobiles; i++) {
      vx[i] += fx[i] / mass[i] * dt;
      vy[i] += fy[i] / mass[i] * dt;
      vz[i] += fz[i] / mass[i] * dt;

      px[i] += vx[i] * dt;
      py[i] += vy[i] * dt;
      pz[i] += vz[i] * dt;
    }
  }

  Real step(Real const & dt) {
    compute_forces();
    apply_forces(dt);
    time += dt;
    return time;
  }

  void State2CSV() {
#if USE_IOSTREAM
    std::cout << time << ",";
    for (Index i = 0; i < ProblemT::counts::mobiles + ProblemT::counts::anchors; ++i) {
      std::cout << px[i] << "," << py[i] << "," << pz[i] << ",";
      std::cout << vx[i] << "," << vy[i] << "," << vz[i] << ",";
      std::cout << fx[i] << "," << fy[i] << "," << fz[i] << ",";
    }
    std::cout << std::endl;
#endif
  }
};

struct problem_0 {
  struct counts {
    static constexpr Index anchors { 1 };
    static constexpr Index mobiles { 4 };
    static constexpr Index springs { 8 };
  };

  struct initializers {
    static void anchors(
        Real * px, Real * py, Real * pz
    ) {
      px[0] = 0.; py[0] = 0.; pz[0] = 1.;
    }

    static void mobiles(
        Real * px, Real * py, Real * pz,
        Real * vx, Real * vy, Real * vz,
        Real * mass, Real * charge
    ) {
      px[0] =  1.; py[0] =  0.; pz[0] = 0.; vx[0] = 0.; vy[0] = 0.; vz[0] = 0.; mass[0] = 1.; charge[0] = 1.;
      px[1] =  0.; py[1] =  1.; pz[1] = 0.; vx[1] = 0.; vy[1] = 0.; vz[1] = 0.; mass[1] = 1.; charge[1] = 1.;
      px[2] = -1.; py[2] =  0.; pz[2] = 0.; vx[2] = 0.; vy[2] = 0.; vz[2] = 0.; mass[2] = 1.; charge[2] = 1.;
      px[3] =  0.; py[3] = -1.; pz[3] = 0.; vx[3] = 0.; vy[3] = 0.; vz[3] = 0.; mass[3] = 1.; charge[3] = 1.;      
    }

    static void springs(
        Index * springs,
        Real  * tension,
        Real  * friction,
        Real  * length 
    ) {
      springs[ 0] = 0; springs[ 1] = 1; tension[0] =   1.; friction[0] = 0.; length[0] = sqrt(2.);
      springs[ 2] = 1; springs[ 3] = 2; tension[1] =   1.; friction[1] = 0.; length[1] = sqrt(2.);
      springs[ 4] = 2; springs[ 5] = 3; tension[2] =   1.; friction[2] = 0.; length[2] = sqrt(2.);
      springs[ 6] = 3; springs[ 7] = 0; tension[3] =   1.; friction[3] = 0.; length[3] = sqrt(2.);

      springs[ 8] = 4; springs[ 9] = 0; tension[4] =   1.; friction[4] = 0.; length[4] = sqrt(2.);
      springs[10] = 4; springs[11] = 1; tension[5] =   1.; friction[5] = 0.; length[5] = sqrt(2.);
      springs[12] = 4; springs[13] = 2; tension[6] =   1.; friction[6] = 0.; length[6] = sqrt(2.);
      springs[14] = 4; springs[15] = 3; tension[7] =   1.; friction[7] = 0.; length[7] = sqrt(2.);
    }
  };

  struct fields {
    struct force {
      static Real x(Real t, Real x, Real y, Real z) { return 0.; }
      static Real y(Real t, Real x, Real y, Real z) { return 0.; }
      static Real z(Real t, Real x, Real y, Real z) { return -1.; }
    };
    struct electric {
      static Real x(Real t, Real x, Real y, Real z) { return 0.; }
      static Real y(Real t, Real x, Real y, Real z) { return 0.; }
      static Real z(Real t, Real x, Real y, Real z) { return 0.; }
    };
    struct magnetic {
      static Real x(Real t, Real x, Real y, Real z) { return 0.; }
      static Real y(Real t, Real x, Real y, Real z) { return 0.; }
      static Real z(Real t, Real x, Real y, Real z) { return 1.; }
    };
  };
};

int main(int argc, char *argv[]) {
  System<problem_0> system;

  Real dt = .001;
  Real stop = 100.;

  system.State2CSV();
  int cnt = 0;
  while (system.step(dt) < stop) {
    if (++cnt % 100 == 0)
      system.State2CSV();
  }

  return 0;
}

